"""Cross-OS .env generator for the AI Sidekick for Splunk lab.

Provides both interactive and non-interactive modes. In tests, prefer
non-interactive via CLI flags.

Feature parity with the historical Bash script (scripts/lab/setup-env.sh):
- Safe overwrite check when an existing .env is present (interactive)
- Optional workshop Google API key auto-suggestion from CSV
- Defaults for MCP URL, model, port, and log level
- One-click workshop Splunk instance preset
- Full set of env keys mirrored from the shell script
"""

from __future__ import annotations

import argparse
import csv
import random
import sys
from getpass import getpass
from pathlib import Path


def print_banner() -> None:
    """Print a friendly header for the setup process."""
    print("\n🚀 AI Sidekick for Splunk Lab Environment Setup")
    print("=================================================")


def print_summary_and_next_steps(
    *,
    mcp_url: str,
    splunk_host: str,
    splunk_port: int,
    splunk_scheme: str,
    splunk_username: str,
    splunk_password_set: bool,
    model: str,
    port: int,
    log_level: str,
) -> None:
    """Print a concise configuration summary and actionable next steps.

    Args:
        mcp_url: MCP server URL
        splunk_host: Splunk host
        splunk_port: Splunk management port
        splunk_scheme: http or https
        splunk_username: Splunk username
        splunk_password_set: Whether a password was provided
        model: LLM model identifier
        port: Local server port
        log_level: Log level string
    """
    print("\n📋 Configuration Summary:")
    print("  Google API Key: [CONFIGURED]")
    print(f"  MCP Server: {mcp_url}")
    print(f"  Splunk Host: {splunk_host}")
    print(f"  Splunk Port: {splunk_port}")
    print(f"  Splunk Scheme: {splunk_scheme}")
    print(f"  Splunk Username: {splunk_username}")
    print("  Splunk Verify SSL: [see .env]")
    print(f"  Splunk Password: {'[CONFIGURED]' if splunk_password_set else '[NOT SET]'}")
    print(f"  Model: {model}")
    print(f"  Server Port: {port}")
    print(f"  Log Level: {log_level}")

    print("\n🎯 Next Steps:")
    if "localhost" in mcp_url or "127.0.0.1" in mcp_url:
        print("  1. Start MCP server: cd mcp-server-for-splunk && ./scripts/build_and_run.sh")
    else:
        print("  1. Start Docker services: docker-compose up -d")
    print("  2. Start AI Sidekick: uv run start-lab")
    print("  3. Access workshop: http://localhost:8087")


def write_env_file(
    target_path: Path,
    google_api_key: str,
    mcp_url: str,
    model: str,
    port: int,
    log_level: str,
    splunk_host: str,
    splunk_port: int,
    splunk_scheme: str,
    splunk_username: str,
    splunk_password: str,
    splunk_verify_ssl: bool,
) -> None:
    """Write a .env file compatible with the lab.

    Args:
        target_path: Destination .env path
        google_api_key: Google AI Studio API key
        mcp_url: MCP server base URL
        model: LLM model identifier
        port: Server port
        log_level: Log level string
        splunk_host: Splunk host
        splunk_port: Splunk mgmt port
        splunk_scheme: http or https
        splunk_username: Splunk username
        splunk_password: Splunk password
        splunk_verify_ssl: Whether to verify SSL certificates
    """
    # Escape single quotes for safe single-quoted env value (match shell behavior)
    safe_password = splunk_password.replace("'", "'\"'\"'")

    content = (
        "# =============================================================================\n"
        "# AI Sidekick for Splunk Lab Environment Configuration\n"
        "# =============================================================================\n"
        "# Generated by setup_env.py\n\n"
        "# =============================================================================\n"
        "# Google ADK Configuration (Required)\n"
        "# =============================================================================\n"
        f"GOOGLE_GENAI_USE_VERTEXAI=False\n"
        f"GOOGLE_API_KEY={google_api_key}\n\n"
        "# LLM Model Configuration\n"
        f"BASE_MODEL={model}\n"
        f"TUTOR_MODEL={model}\n\n"
        "# =============================================================================\n"
        "# MCP Server Configuration (Required for Splunk Integration)\n"
        "# =============================================================================\n"
        f"SPLUNK_MCP_SERVER_URL={mcp_url}\n\n"
        "# Splunk Connection Details (Required for MCP server)\n"
        f"SPLUNK_HOST='{splunk_host}'\n"
        f"SPLUNK_PORT='{splunk_port}'\n"
        f"SPLUNK_SCHEME='{splunk_scheme}'\n"
        f"SPLUNK_USERNAME='{splunk_username}'\n"
        f"SPLUNK_PASSWORD='{safe_password}'\n"
        f"SPLUNK_VERIFY_SSL='{str(splunk_verify_ssl).lower()}'\n\n"
        "# =============================================================================\n"
        "# Core ADK Agent Configuration (Required)\n"
        "# =============================================================================\n"
        "ADK_AGENT_MODULE_PATH=src.backend.app.agent\n"
        "ADK_AGENT_INSTANCE_NAME=root_agent\n\n"
        "# =============================================================================\n"
        "# Workshop Server Configuration\n"
        "# =============================================================================\n"
        "APP_NAME=\"AI Sidekick for Splunk\"\n"
        "DEBUG=false\n"
        "HOST=0.0.0.0\n"
        f"PORT={port}\n"
        "FASTAPI_HOST=0.0.0.0\n"
        f"FASTAPI_PORT={port}\n"
        f"LOG_LEVEL={log_level}\n\n"
        "# =============================================================================\n"
        "# Additional Configuration\n"
        "# =============================================================================\n"
        "VERSION=1.0.0\n"
        "RELOAD=false\n"
        "CORS_ORIGINS=[\"*\"]\n"
        "CORS_ALLOW_CREDENTIALS=true\n"
        "DEV_MODE=true\n"
        "SHOW_DETAILED_ERRORS=true\n"
    )
    target_path.write_text(content)


def resolve_project_root(start: Path | None = None) -> Path:
    """Find project root by locating pyproject.toml upward from start or cwd."""
    start_path = (start or Path.cwd()).resolve()
    for parent in [start_path, *start_path.parents]:
        if (parent / "pyproject.toml").exists():
            return parent
    return start_path


DEFAULTS: dict[str, str] = {
    "MCP_URL": "http://localhost:8003/mcp/",
    "MODEL": "gemini-2.0-flash-exp",
    "PORT": "8000",
    "LOG_LEVEL": "info",
}


def read_existing_env(path: Path) -> dict[str, str]:
    """Best-effort read of key=value pairs from an existing .env file.

    Args:
        path: Path to .env file

    Returns:
        Mapping of keys to unquoted string values
    """
    if not path.exists():
        return {}
    result: dict[str, str] = {}
    for line in path.read_text().splitlines():
        if not line or line.strip().startswith("#"):
            continue
        if "=" not in line:
            continue
        key, raw_val = line.split("=", 1)
        val = raw_val.strip()
        if (val.startswith("\"") and val.endswith("\"")) or (val.startswith("'") and val.endswith("'")):
            val = val[1:-1]
        result[key.strip()] = val
    return result


def suggest_workshop_key(csv_path: Path) -> str | None:
    """Suggest a Google API key from workshop CSV if available.

    Args:
        csv_path: Path to the workshop participants CSV

    Returns:
        A key string if found, otherwise None
    """
    if not csv_path.exists():
        return None
    candidates: list[str] = []
    try:
        with csv_path.open(newline="") as f:
            reader = csv.reader(f)
            next(reader, None)  # skip header
            for row in reader:
                if len(row) >= 3 and row[2].strip():
                    candidates.append(row[2].strip())
    except (OSError, csv.Error, UnicodeDecodeError):
        return None
    if not candidates:
        return None
    return random.choice(candidates)


def interactive_setup(target_path: Path) -> None:
    """Run interactive prompts to generate a .env file.

    Mirrors core behavior of the historical shell script while remaining cross-OS.
    """
    print("This will generate a .env file used by the workshop services.")
    print("It will either create a new file or overwrite the existing one if you confirm.\n")
    existing = read_existing_env(target_path)

    if target_path.exists():
        resp = input(".env exists. Overwrite? (y/N): ").strip() or "N"
        if resp.lower() != "y":
            print("Keeping existing .env file.")
            return

    print("\n🔑 Google AI Studio Configuration")
    print("Get your API key from: https://aistudio.google.com/app/apikey")

    workshop_csv = resolve_project_root() / "internal/admin/workshop-management/workshop-participants.csv"
    google_api_key = existing.get("GOOGLE_API_KEY", "")
    if workshop_csv.exists():
        auto_choice = (input("Autogenerate Google API key for this workshop? (Y/n): ").strip() or "Y").lower()
        if auto_choice == "y":
            suggestion = suggest_workshop_key(workshop_csv)
            if suggestion:
                print(f"Found a workshop key (masked): ****{suggestion[-4:]}")
                entered = getpass("Press Enter to accept or paste a different key: ")
                google_api_key = entered or suggestion

    while not google_api_key or google_api_key == "your-google-ai-studio-api-key":
        google_api_key = getpass("Enter your Google AI Studio API key: ")
        if google_api_key:
            break
        print("Please provide a valid Google API key")

    print("\n🔧 MCP Server Configuration")
    default_mcp = existing.get("SPLUNK_MCP_SERVER_URL", DEFAULTS["MCP_URL"])  # keep existing if present
    mcp_url = input(f"MCP server URL [{default_mcp}]: ").strip() or default_mcp

    print("\n🔗 Splunk Connection Configuration")
    print("The MCP server needs to connect to your Splunk instance.")
    use_workshop = (input("Use workshop Splunk instance (dev*.splunk.show)? (Y/n): ").strip() or "Y").lower() == "y"
    if use_workshop:
        splunk_host = "dev1666-i-035e95d7e4ea1c310.splunk.show"
        splunk_port = 8089
        splunk_scheme = "https"
        splunk_username = "admin"
        splunk_verify_ssl = True
        print("Using workshop Splunk instance")
    else:
        splunk_host = input("Splunk host [blank keeps existing if present]: ").strip() or existing.get("SPLUNK_HOST", "")
        splunk_port_str = input("Splunk port [8089]: ").strip() or existing.get("SPLUNK_PORT", "8089")
        splunk_port = int(splunk_port_str)
        splunk_scheme = input("Splunk scheme (http/https) [https]: ").strip() or existing.get("SPLUNK_SCHEME", "https")
        splunk_username = input("Splunk username [admin]: ").strip() or existing.get("SPLUNK_USERNAME", "admin")
        verify_str = input("Verify SSL certificates? (true/false) [true]: ").strip() or existing.get("SPLUNK_VERIFY_SSL", "true")
        splunk_verify_ssl = verify_str.lower() == "true"

    print("")
    # Always prompt for password with ability to keep existing
    existing_pw = existing.get("SPLUNK_PASSWORD", "")
    if existing_pw:
        entered_pw = getpass("Splunk password [press Enter to keep existing]: ")
        splunk_password = existing_pw if not entered_pw else entered_pw
    else:
        splunk_password = getpass("Splunk password: ")

    print("\n🤖 Model Configuration")
    default_model = existing.get("BASE_MODEL", DEFAULTS["MODEL"])
    model = input(f"LLM Model [{default_model}]: ").strip() or default_model

    print("\n🌐 Server Configuration")
    default_port = existing.get("PORT", DEFAULTS["PORT"]).strip()
    port = int(input(f"Server port [{default_port}]: ").strip() or default_port)
    default_log = existing.get("LOG_LEVEL", DEFAULTS["LOG_LEVEL"])  # keep existing if present
    log_level = input(f"Log level [{default_log}]: ").strip() or default_log

    write_env_file(
        target_path=target_path,
        google_api_key=google_api_key,
        mcp_url=mcp_url,
        model=model,
        port=port,
        log_level=log_level,
        splunk_host=splunk_host,
        splunk_port=splunk_port,
        splunk_scheme=splunk_scheme,
        splunk_username=splunk_username,
        splunk_password=splunk_password,
        splunk_verify_ssl=splunk_verify_ssl,
    )
    print(".env file created successfully.")
    print_summary_and_next_steps(
        mcp_url=mcp_url,
        splunk_host=splunk_host,
        splunk_port=splunk_port,
        splunk_scheme=splunk_scheme,
        splunk_username=splunk_username,
        splunk_password_set=bool(splunk_password),
        model=model,
        port=port,
        log_level=log_level,
    )


def main(argv: list[str] | None = None) -> None:
    parser = argparse.ArgumentParser(description="Generate .env for the lab")
    mode = parser.add_mutually_exclusive_group()
    mode.add_argument("--interactive", action="store_true", help="Run interactive setup prompts")
    mode.add_argument("--non-interactive", action="store_true", help="Require all values via flags")

    # Non-interactive flags (also accepted in interactive mode to prefill)
    parser.add_argument("--google-api-key")
    parser.add_argument("--mcp-url")
    parser.add_argument("--model", default=DEFAULTS["MODEL"])
    parser.add_argument("--port", type=int, default=int(DEFAULTS["PORT"]))
    parser.add_argument("--log-level", default=DEFAULTS["LOG_LEVEL"])
    parser.add_argument("--splunk-host")
    parser.add_argument("--splunk-port", type=int, default=8089)
    parser.add_argument("--splunk-scheme", choices=["http", "https"], default="https")
    parser.add_argument("--splunk-username", default="admin")
    parser.add_argument("--splunk-password")
    parser.add_argument("--splunk-verify-ssl", choices=["true", "false"], default="true")
    parser.add_argument("--output", type=Path, default=Path(".env"))

    args = parser.parse_args(argv)

    project_root = resolve_project_root()
    target_path = (project_root / args.output).resolve()
    print_banner()
    print(f"Planned action: write environment file at {target_path}")
    print("If the file exists, you'll be asked whether to overwrite it.\n")

    try:
        # Interactive by default when no non-interactive flag and insufficient flags provided
        if args.interactive or not args.non_interactive and not (
            args.google_api_key and args.mcp_url and args.splunk_host and args.splunk_password
        ):
            interactive_setup(target_path)
            return

        # Non-interactive path: require all key flags
        if not args.google_api_key:
            raise SystemExit("--google-api-key is required in non-interactive mode")
        if not args.mcp_url:
            raise SystemExit("--mcp-url is required in non-interactive mode")
        if not args.splunk_host:
            raise SystemExit("--splunk-host is required in non-interactive mode")
        if not args.splunk_password:
            raise SystemExit("--splunk-password is required in non-interactive mode")

        write_env_file(
            target_path=target_path,
            google_api_key=args.google_api_key,
            mcp_url=args.mcp_url,
            model=args.model,
            port=args.port,
            log_level=args.log_level,
            splunk_host=args.splunk_host,
            splunk_port=args.splunk_port,
            splunk_scheme=args.splunk_scheme,
            splunk_username=args.splunk_username,
            splunk_password=args.splunk_password,
            splunk_verify_ssl=(args.splunk_verify_ssl.lower() == "true"),
        )
        print(".env file created successfully.")
        print_summary_and_next_steps(
            mcp_url=args.mcp_url,
            splunk_host=args.splunk_host,
            splunk_port=args.splunk_port,
            splunk_scheme=args.splunk_scheme,
            splunk_username=args.splunk_username,
            splunk_password_set=bool(args.splunk_password),
            model=args.model,
            port=args.port,
            log_level=args.log_level,
        )
    except (KeyboardInterrupt, EOFError):
        print("\nOperation cancelled by user.")
        sys.exit(130)


if __name__ == "__main__":
    main()
